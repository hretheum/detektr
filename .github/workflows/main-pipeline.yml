name: Main CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'build-and-deploy'
        type: choice
        options:
          - build-and-deploy
          - build-only
          - deploy-only
      services:
        description: 'Services to process (comma-separated or "all" or "changed")'
        default: 'changed'
        required: false
      force_all:
        description: 'Force build all services (overrides services input)'
        type: boolean
        default: false
      tag:
        description: 'Custom tag for images (default: latest)'
        default: 'latest'
        required: false

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/hretheum/detektr

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # =================================
  # 1. DETECT CHANGES
  # =================================
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.determine-services.outputs.services }}
      matrix: ${{ steps.determine-services.outputs.matrix }}
      should_build: ${{ steps.determine-services.outputs.should_build }}
      should_deploy: ${{ steps.determine-services.outputs.should_deploy }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper comparison

      - name: Debug Git Info
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Event action: ${{ github.event.action }}"
          echo "Before SHA: ${{ github.event.before }}"
          echo "After SHA: ${{ github.event.after }}"
          echo "Current SHA: $(git rev-parse HEAD)"
          echo "Previous SHA: $(git rev-parse HEAD~1)"
          echo "Changed files in last commit:"
          git diff --name-only HEAD~1 HEAD || true

      - name: Detect changed files
        id: changes
        if: github.event.inputs.force_all != 'true'
        uses: dorny/paths-filter@v3
        with:
          base: ${{ github.event.before || 'HEAD~1' }}
          filters: |
            rtsp-capture:
              - 'services/rtsp-capture/**'
              - 'docker-compose.rtsp.yml'
            frame-tracking:
              - 'services/frame-tracking/**'
            frame-buffer:
              - 'services/frame-buffer/**'
            telegram-alerts:
              - 'services/telegram-alerts/**'
            metadata-storage:
              - 'services/metadata-storage/**'
            example-otel:
              - 'services/example-otel/**'
            echo-service:
              - 'services/echo-service/**'
            gpu-demo:
              - 'services/gpu-demo/**'
            timescaledb:
              - 'services/timescaledb/**'
              - 'docker-compose.storage.yml'
            base-template:
              - 'services/base-template/**'
            face-recognition:
              - 'services/face-recognition/**'
            object-detection:
              - 'services/object-detection/**'
            ha-bridge:
              - 'services/ha-bridge/**'
            llm-intent:
              - 'services/llm-intent/**'
            sample-processor:
              - 'examples/sample-processor/**'
              - 'services/shared/base-processor/**'

      - name: Determine services to build
        id: determine-services
        run: |
          # Initialize arrays
          services=()

          # Handle different scenarios
          if [[ "${{ github.event.inputs.force_all }}" == "true" ]] || [[ "${{ github.event.inputs.services }}" == "all" ]]; then
            # Build all services
            services=(
              "rtsp-capture"
              "frame-tracking"
              "frame-buffer"
              "telegram-alerts"
              "metadata-storage"
              "example-otel"
              "echo-service"
              "gpu-demo"
              "timescaledb"
              "base-template"
              "face-recognition"
              "object-detection"
              "ha-bridge"
              "llm-intent"
              "sample-processor"
            )
          elif [[ "${{ github.event.inputs.services }}" == "changed" ]] || [[ -z "${{ github.event.inputs.services }}" ]]; then
            # Use detected changes
            changes='${{ toJSON(steps.changes.outputs.changes) }}'
            echo "DEBUG: Raw changes from path-filter: $changes"
            echo "DEBUG: All outputs from path-filter:"
            echo '${{ toJSON(steps.changes.outputs) }}'

            # If no manual services specified and we have a push event, detect changes from git
            if [[ -z "${{ github.event.inputs.services }}" ]] && [[ "${{ github.event_name }}" == "push" ]]; then
              echo "Detecting changes from git diff..."
              changed_files=$(git diff --name-only ${{ github.event.before }} ${{ github.event.after }} 2>/dev/null || git diff --name-only HEAD~1 HEAD)
              echo "Changed files: $changed_files"

              # Check each service path
              for service in rtsp-capture frame-tracking frame-buffer telegram-alerts metadata-storage example-otel echo-service gpu-demo timescaledb base-template face-recognition object-detection ha-bridge llm-intent sample-processor; do
                service_path="services/$service"
                if [[ "$service" == "sample-processor" ]]; then
                  service_path="examples/sample-processor"
                fi

                if echo "$changed_files" | grep -q "$service_path\|services/shared/base-processor"; then
                  echo "Service $service has changes (detected from git)"
                  services+=("$service")
                fi
              done
            fi

            if [[ "$changes" != "{}" && "$changes" != "null" && "$changes" != "[]" ]]; then
              # Parse JSON and extract service names that changed
              for service in rtsp-capture frame-tracking frame-buffer telegram-alerts metadata-storage example-otel echo-service gpu-demo timescaledb base-template face-recognition object-detection ha-bridge llm-intent sample-processor; do
                # Check from path-filter output directly
                service_key=$(echo "$service" | tr '-' '_')
                # Use direct check for each service
                service_changed="false"
                case "$service" in
                  "sample-processor") service_changed="${{ steps.changes.outputs.sample-processor }}" ;;
                  "rtsp-capture") service_changed="${{ steps.changes.outputs.rtsp-capture }}" ;;
                  "frame-tracking") service_changed="${{ steps.changes.outputs.frame-tracking }}" ;;
                  "frame-buffer") service_changed="${{ steps.changes.outputs.frame-buffer }}" ;;
                  "telegram-alerts") service_changed="${{ steps.changes.outputs.telegram-alerts }}" ;;
                  "metadata-storage") service_changed="${{ steps.changes.outputs.metadata-storage }}" ;;
                  "example-otel") service_changed="${{ steps.changes.outputs.example-otel }}" ;;
                  "echo-service") service_changed="${{ steps.changes.outputs.echo-service }}" ;;
                  "gpu-demo") service_changed="${{ steps.changes.outputs.gpu-demo }}" ;;
                  "timescaledb") service_changed="${{ steps.changes.outputs.timescaledb }}" ;;
                  "base-template") service_changed="${{ steps.changes.outputs.base-template }}" ;;
                  "face-recognition") service_changed="${{ steps.changes.outputs.face-recognition }}" ;;
                  "object-detection") service_changed="${{ steps.changes.outputs.object-detection }}" ;;
                  "ha-bridge") service_changed="${{ steps.changes.outputs.ha-bridge }}" ;;
                  "llm-intent") service_changed="${{ steps.changes.outputs.llm-intent }}" ;;
                  *)
                    # For any service not explicitly handled, try to parse from JSON
                    if [[ "$changes" != "null" ]] && [[ "$changes" != "[]" ]] && [[ "$changes" != "{}" ]]; then
                      service_changed=$(echo "$changes" | jq -r ".\"$service\" // false" 2>/dev/null || echo "false")
                    else
                      service_changed="false"
                    fi
                    ;;
                esac

                if [[ "$service_changed" == "true" ]]; then
                  echo "DEBUG: Service $service has changes"
                  services+=("$service")
                fi
              done
            fi

            # If only workflow files changed, check recent changes
            if [[ ${#services[@]} -eq 0 ]] && echo "$changed_files" | grep -qE '^\.(github/workflows|github/actions)'; then
              echo "Only workflow files changed, checking recent service changes..."
              # Look at last 10 commits for service changes
              recent_changes=$(git diff --name-only HEAD~10 HEAD | grep -E '^(services|examples)/' | sort -u)
              for service in rtsp-capture frame-tracking sample-processor; do
                service_path="services/$service"
                if [[ "$service" == "sample-processor" ]]; then
                  service_path="examples/sample-processor"
                fi
                if echo "$recent_changes" | grep -q "$service_path"; then
                  echo "Service $service had recent changes"
                  services+=("$service")
                fi
              done
            fi
          elif [[ -n "${{ github.event.inputs.services }}" ]]; then
            # Use manually specified services
            IFS=',' read -ra SERVICES_ARRAY <<< "${{ github.event.inputs.services }}"
            for service in "${SERVICES_ARRAY[@]}"; do
              services+=("$(echo $service | xargs)")  # trim whitespace
            done
          fi

          # Determine actions based on input
          should_build="true"
          should_deploy="true"

          if [[ "${{ github.event.inputs.action }}" == "build-only" ]]; then
            should_deploy="false"
          elif [[ "${{ github.event.inputs.action }}" == "deploy-only" ]]; then
            should_build="false"
          fi

          # Output results
          if [ ${#services[@]} -eq 0 ]; then
            echo "services=" >> $GITHUB_OUTPUT
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
          else
            services_json=$(printf '%s\n' "${services[@]}" | jq -R . | jq -s .)
            echo "services=${services[*]}" >> $GITHUB_OUTPUT

            # Create matrix for parallel builds
            matrix_json='{"include":['
            first=true
            for service in "${services[@]}"; do
              if [ "$first" = true ]; then
                first=false
              else
                matrix_json+=','
              fi
              matrix_json+="{\"service\":\"$service\"}"
            done
            matrix_json+=']}'
            echo "matrix=$matrix_json" >> $GITHUB_OUTPUT
          fi

          echo "should_build=$should_build" >> $GITHUB_OUTPUT
          echo "should_deploy=$should_deploy" >> $GITHUB_OUTPUT

          # Debug outputs
          echo "DEBUG: services array has ${#services[@]} elements"
          echo "DEBUG: services output: ${services[*]}"
          echo "DEBUG: matrix output: $matrix_json"

          # Summary
          echo "### ðŸ“‹ Pipeline Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Action**: ${{ github.event.inputs.action || 'build-and-deploy' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Should Build**: $should_build" >> $GITHUB_STEP_SUMMARY
          echo "- **Should Deploy**: $should_deploy" >> $GITHUB_STEP_SUMMARY
          echo "- **Services**: ${services[*]:-none}" >> $GITHUB_STEP_SUMMARY
          echo "- **Matrix**: $matrix_json" >> $GITHUB_STEP_SUMMARY

  # =================================
  # 2. BUILD SERVICES
  # =================================
  build:
    name: Build ${{ matrix.service }}
    needs: detect-changes
    if: |
      needs.detect-changes.outputs.should_build == 'true' &&
      needs.detect-changes.outputs.matrix != '{"include":[]}'
    runs-on: self-hosted
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.detect-changes.outputs.matrix) }}
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_PREFIX }}/${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=${{ github.event.inputs.tag || 'latest' }}
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.service == 'sample-processor' && 'examples/sample-processor/Dockerfile' || format('services/{0}/Dockerfile', matrix.service) }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            SERVICE_NAME=${{ matrix.service }}

  # =================================
  # 3. DEPLOY TO NEBULA
  # =================================
  deploy:
    name: Deploy to Nebula
    needs: [detect-changes, build]
    if: |
      always() &&
      needs.detect-changes.outputs.should_deploy == 'true' &&
      (needs.build.result == 'success' || needs.build.result == 'skipped')
    runs-on: self-hosted
    steps:
      - name: Pre-deployment cleanup
        run: |
          echo "ðŸ§¹ Pre-deployment cleanup..."
          # Clean any existing checkout
          sudo rm -rf ${{ github.workspace }}/* || true
          sudo rm -rf ${{ github.workspace }}/.* 2>/dev/null || true

          # Clean Docker system (optional, be careful)
          docker system prune -f || true

      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            scripts/deploy.sh
            docker/
            .env.sops
          sparse-checkout-cone-mode: false

      - name: Deploy using unified script
        run: |
          echo "ðŸš€ Deploying to Nebula using unified deployment script..."

          # Test GitHub registry access
          echo "Testing GitHub registry access..."
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin || {
            echo "âš ï¸ Warning: Failed to login to ghcr.io"
          }

          # List current images before deployment
          echo "Current images on runner:"
          docker images | grep detektr || echo "No detektr images found"

          # Copy only deployment files to clean directory
          DEPLOY_DIR="/opt/detektor-clean"

          # Ensure clean directory exists and is clean
          sudo rm -rf $DEPLOY_DIR/docker $DEPLOY_DIR/scripts
          sudo mkdir -p $DEPLOY_DIR
          sudo chown -R $USER:$USER $DEPLOY_DIR

          # Copy only necessary files
          cp -r ${{ github.workspace }}/docker $DEPLOY_DIR/
          cp -r ${{ github.workspace }}/scripts $DEPLOY_DIR/

          # Copy existing .env from deployment location if it exists
          if [ -f "$DEPLOY_DIR/.env" ]; then
            echo "ðŸ“‹ Using existing .env from $DEPLOY_DIR/.env"
          elif [ -f "/opt/detektor/.env" ]; then
            echo "ðŸ“‹ Copying existing .env from /opt/detektor/.env"
            cp /opt/detektor/.env $DEPLOY_DIR/
          elif [ -f "${{ github.workspace }}/.env.sops" ]; then
            cp ${{ github.workspace }}/.env.sops $DEPLOY_DIR/
          fi

          # Change to deployment directory
          cd $DEPLOY_DIR

          # Determine environment
          ENVIRONMENT="production"
          if [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            ENVIRONMENT="staging"
          fi

          # Run deployment from clean directory
          export IMAGE_TAG="${{ github.event.inputs.tag || 'latest' }}"
          export DEPLOY_SERVICES="${{ needs.detect-changes.outputs.services }}"
          export GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          export GITHUB_ACTOR="${{ github.actor }}"

          echo "ðŸ“¦ Environment: $ENVIRONMENT"
          echo "ðŸ“¦ Services: $DEPLOY_SERVICES"
          echo "ðŸ“¦ Tag: $IMAGE_TAG"
          echo "ðŸ“¦ Deploy Directory: $DEPLOY_DIR"

          # Execute deployment with proper project name
          export COMPOSE_PROJECT_NAME=detektor
          ./scripts/deploy.sh "$ENVIRONMENT" deploy || {
            echo "âŒ Deployment failed"
            exit 1
          }

          # Verify deployment
          echo "ðŸ” Verifying deployment..."
          ./scripts/deploy.sh "$ENVIRONMENT" verify || {
            echo "âš ï¸ Some services may not be healthy"
            # Don't fail here, just warn
          }

      - name: Post-deployment cleanup
        if: always()
        run: |
          echo "ðŸ§¹ Post-deployment cleanup..."
          # Clean runner workspace - NO source code should remain
          sudo rm -rf ${{ github.workspace }}/* || true
          sudo rm -rf ${{ github.workspace }}/.* 2>/dev/null || true

          # Verify deployment directory has no source code
          echo "ðŸ“ Contents of deployment directory:"
          ls -la /opt/detektor-clean/ || true

          # Old contaminated directory - to be removed later
          echo "âš ï¸ WARNING: /opt/detektor contains source code and should be removed!"

  # =================================
  # 4. SUMMARY
  # =================================
  summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, build, deploy]
    if: always()
    steps:
      - name: Generate summary
        run: |
          echo "## ðŸš€ Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Configuration
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Action**: ${{ github.event.inputs.action || 'build-and-deploy' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag**: ${{ github.event.inputs.tag || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Services**: ${{ needs.detect-changes.outputs.services || 'none' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Results
          echo "### Results" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Detect Changes | ${{ needs.detect-changes.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy | ${{ needs.deploy.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Overall status
          if [[ "${{ needs.deploy.result }}" == "success" || "${{ needs.deploy.result }}" == "skipped" ]]; then
            echo "âœ… **Pipeline completed successfully**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Pipeline failed**" >> $GITHUB_STEP_SUMMARY
          fi
